/**
 * Matrix Logger - Text rendering system for Arduino LED Matrix
 * Based on font8x8_basic.h by Daniel Hepper
 * 
 * This header file provides functions to display text on the 8x12 LED matrix
 * found on Arduino UNO R4 WiFi boards.
 */

 #ifndef MATRIX_LOGGER_H
 #define MATRIX_LOGGER_H
 
 #include <Arduino.h>
 #include "Arduino_LED_Matrix.h"
 
 // Log levels
 #define LOG_LEVEL_DEBUG    0
 #define LOG_LEVEL_INFO     1
 #define LOG_LEVEL_WARNING  2
 #define LOG_LEVEL_ERROR    3
 
 // Current log level (change this to filter messages)
 #define CURRENT_LOG_LEVEL  LOG_LEVEL_INFO
 
 // Special characters
 #define CHAR_ARROW_RIGHT 127
 #define CHAR_ARROW_LEFT  126
 #define CHAR_CHECKMARK   125
 #define CHAR_CROSS       124
 #define CHAR_HEART       123
 #define CHAR_DEGREE      122
 
 class MatrixLogger {
   private:
     ArduinoLEDMatrix* matrix;
     byte frame[8][12] = {0};
     unsigned long scrollDelay = 100;  // Milliseconds between scroll steps
     int currentLogLevel = CURRENT_LOG_LEVEL;
     char scrollBuffer[64];            // Buffer for scrolling text
     int scrollBufferLength = 0;
     int scrollPosition = 0;
     unsigned long lastScrollTime = 0;
     bool isScrolling = false;
     
     // This 5x8 font is adapted from font8x8_basic.h but optimized for the smaller width
     // Each character takes 5 columns plus 1 column spacing
     static const byte font5x8[128][8];
 
     // Copy a character from the font into the frame at the specified position
     void renderCharacter(char c, int xOffset) {
       byte charIndex = (byte)c;
       
       // Don't render if the character would be completely off-screen
       if (xOffset >= 12 || xOffset <= -5)
         return;
       
       // Copy the character bitmap to the frame buffer
       for (int y = 0; y < 8; y++) {
         for (int x = 0; x < 5; x++) {
           int targetX = x + xOffset;
           
           // Only draw pixels that are within the frame
           if (targetX >= 0 && targetX < 12) {
             // Check if the bit at position x in the font for this character's row is set
             bool pixelOn = bitRead(font5x8[charIndex][y], 7-x);
             
             // Set or clear the pixel in the frame
             frame[y][targetX] = pixelOn ? 1 : 0;
           }
         }
       }
     }
 
   public:
     // Constructor
     MatrixLogger(ArduinoLEDMatrix* ledMatrix) {
       matrix = ledMatrix;
     }
     
     // Set the current log level
     void setLogLevel(int level) {
       currentLogLevel = level;
     }
     
     // Set the scroll speed (delay in milliseconds)
     void setScrollSpeed(unsigned long delay) {
       scrollDelay = delay;
     }
     
     // Clear the frame
     void clear() {
       memset(frame, 0, sizeof(frame[0][0]) * 8 * 12);
       matrix->renderBitmap(frame, 8, 12);
     }
     
     // Display a static message (up to 2 characters)
     void print(const char* message, int duration = 1000) {
       // Clear the frame
       clear();
       
       // Display up to 2 characters
       if (message[0]) renderCharacter(message[0], 0);
       if (message[1]) renderCharacter(message[1], 6);
       
       // Update the matrix
       matrix->renderBitmap(frame, 8, 12);
       
       // Wait for the specified duration
       delay(duration);
     }
     
     // Start scrolling a message
     void scroll(const char* message) {
       // Copy the message to the scroll buffer
       strncpy(scrollBuffer, message, sizeof(scrollBuffer) - 1);
       scrollBuffer[sizeof(scrollBuffer) - 1] = '\0';
       
       // Calculate the length of the message
       scrollBufferLength = strlen(scrollBuffer);
       
       // Start from the rightmost position
       scrollPosition = 12;
       
       // Set the scrolling flag
       isScrolling = true;
       
       // Record the current time
       lastScrollTime = millis();
     }
     
     // Update the scrolling text (call this in loop())
     void update() {
       if (!isScrolling) return;
       
       unsigned long currentTime = millis();
       
       // Check if it's time to update the scroll position
       if (currentTime - lastScrollTime >= scrollDelay) {
         lastScrollTime = currentTime;
         
         // Clear the frame
         memset(frame, 0, sizeof(frame[0][0]) * 8 * 12);
         
         // Calculate end position (-5 for character width)
         int endPosition = -5 * scrollBufferLength;
         
         // Render characters at their current positions
         for (int i = 0; i < scrollBufferLength; i++) {
           int charPos = scrollPosition + (i * 6);
           renderCharacter(scrollBuffer[i], charPos);
         }
         
         // Update the matrix
         matrix->renderBitmap(frame, 8, 12);
         
         // Move the text one pixel to the left
         scrollPosition--;
         
         // Check if the text has scrolled completely off the left side
         if (scrollPosition < endPosition) {
           // Stop scrolling
           isScrolling = false;
           
           // Clear the frame
           clear();
         }
       }
     }
     
     // Log messages with different log levels
     void debug(const char* message) {
       if (currentLogLevel <= LOG_LEVEL_DEBUG) {
         scroll(message);
       }
     }
     
     void info(const char* message) {
       if (currentLogLevel <= LOG_LEVEL_INFO) {
         scroll(message);
       }
     }
     
     void warning(const char* message) {
       if (currentLogLevel <= LOG_LEVEL_WARNING) {
         // Show warning icon then scroll message
         char icon[3] = "! ";
         print(icon, 500);
         scroll(message);
       }
     }
     
     void error(const char* message) {
       if (currentLogLevel <= LOG_LEVEL_ERROR) {
         // Flash error icon then scroll message
         char icon[3] = "X ";
         for (int i = 0; i < 3; i++) {
           print(icon, 300);
           clear();
           delay(200);
         }
         scroll(message);
       }
     }
 };
 
 // Adapted 5x8 font (first 5 bits of each byte are used) based on font8x8_basic.h
 const byte MatrixLogger::font5x8[128][8] = {
     {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // U+0000 (nul)
     {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // U+0001
     {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // U+0002
     {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // U+0003
     {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // U+0004
     {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // U+0005
     {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // U+0006
     {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // U+0007
     {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // U+0008
     {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // U+0009
     {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // U+000A
     {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // U+000B
     {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // U+000C
     {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // U+000D
     {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // U+000E
     {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // U+000F
     {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // U+0010
     {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // U+0011
     {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // U+0012
     {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // U+0013
     {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // U+0014
     {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // U+0015
     {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // U+0016
     {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // U+0017
     {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // U+0018
     {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // U+0019
     {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // U+001A
     {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // U+001B
     {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // U+001C
     {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // U+001D
     {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // U+001E
     {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // U+001F
     {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // U+0020 (space)
     {0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x00, 0x00}, // U+0021 (!)
     {0x00, 0x07, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00}, // U+0022 (")
     {0x14, 0x7F, 0x14, 0x7F, 0x14, 0x00, 0x00, 0x00}, // U+0023 (#)
     {0x24, 0x2A, 0x7F, 0x2A, 0x12, 0x00, 0x00, 0x00}, // U+0024 ($)
     {0x23, 0x13, 0x08, 0x64, 0x62, 0x00, 0x00, 0x00}, // U+0025 (%)
     {0x36, 0x49, 0x55, 0x22, 0x50, 0x00, 0x00, 0x00}, // U+0026 (&)
     {0x00, 0x05, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00}, // U+0027 (')
     {0x00, 0x1C, 0x22, 0x41, 0x00, 0x00, 0x00, 0x00}, // U+0028 (()
     {0x00, 0x41, 0x22, 0x1C, 0x00, 0x00, 0x00, 0x00}, // U+0029 ())
     {0x14, 0x08, 0x3E, 0x08, 0x14, 0x00, 0x00, 0x00}, // U+002A (*)
     {0x08, 0x08, 0x3E, 0x08, 0x08, 0x00, 0x00, 0x00}, // U+002B (+)
     {0x00, 0x50, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00}, // U+002C (,)
     {0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00}, // U+002D (-)
     {0x00, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00}, // U+002E (.)
     {0x20, 0x10, 0x08, 0x04, 0x02, 0x00, 0x00, 0x00}, // U+002F (/)
     {0x3E, 0x51, 0x49, 0x45, 0x3E, 0x00, 0x00, 0x00}, // U+0030 (0)
     {0x00, 0x42, 0x7F, 0x40, 0x00, 0x00, 0x00, 0x00}, // U+0031 (1)
     {0x42, 0x61, 0x51, 0x49, 0x46, 0x00, 0x00, 0x00}, // U+0032 (2)
     {0x21, 0x41, 0x45, 0x4B, 0x31, 0x00, 0x00, 0x00}, // U+0033 (3)
     {0x18, 0x14, 0x12, 0x7F, 0x10, 0x00, 0x00, 0x00}, // U+0034 (4)
     {0x27, 0x45, 0x45, 0x45, 0x39, 0x00, 0x00, 0x00}, // U+0035 (5)
     {0x3C, 0x4A, 0x49, 0x49, 0x30, 0x00, 0x00, 0x00}, // U+0036 (6)
     {0x01, 0x71, 0x09, 0x05, 0x03, 0x00, 0x00, 0x00}, // U+0037 (7)
     {0x36, 0x49, 0x49, 0x49, 0x36, 0x00, 0x00, 0x00}, // U+0038 (8)
     {0x06, 0x49, 0x49, 0x29, 0x1E, 0x00, 0x00, 0x00}, // U+0039 (9)
     {0x00, 0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00}, // U+003A (:)
     {0x00, 0x56, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00}, // U+003B (;)
     {0x08, 0x14, 0x22, 0x41, 0x00, 0x00, 0x00, 0x00}, // U+003C (<)
     {0x14, 0x14, 0x14, 0x14, 0x14, 0x00, 0x00, 0x00}, // U+003D (=)
     {0x00, 0x41, 0x22, 0x14, 0x08, 0x00, 0x00, 0x00}, // U+003E (>)
     {0x02, 0x01, 0x51, 0x09, 0x06, 0x00, 0x00, 0x00}, // U+003F (?)
     {0x32, 0x49, 0x79, 0x41, 0x3E, 0x00, 0x00, 0x00}, // U+0040 (@)
     {0x7E, 0x11, 0x11, 0x11, 0x7E, 0x00, 0x00, 0x00}, // U+0041 (A)
     {0x7F, 0x49, 0x49, 0x49, 0x36, 0x00, 0x00, 0x00}, // U+0042 (B)
     {0x3E, 0x41, 0x41, 0x41, 0x22, 0x00, 0x00, 0x00}, // U+0043 (C)
     {0x7F, 0x41, 0x41, 0x22, 0x1C, 0x00, 0x00, 0x00}, // U+0044 (D)
     {0x7F, 0x49, 0x49, 0x49, 0x41, 0x00, 0x00, 0x00}, // U+0045 (E)
     {0x7F, 0x09, 0x09, 0x09, 0x01, 0x00, 0x00, 0x00}, // U+0046 (F)
     {0x3E, 0x41, 0x49, 0x49, 0x7A, 0x00, 0x00, 0x00}, // U+0047 (G)
     {0x7F, 0x08, 0x08, 0x08, 0x7F, 0x00, 0x00, 0x00}, // U+0048 (H)
     {0x00, 0x41, 0x7F, 0x41, 0x00, 0x00, 0x00, 0x00}, // U+0049 (I)
     {0x20, 0x40, 0x41, 0x3F, 0x01, 0x00, 0x00, 0x00}, // U+004A (J)
     {0x7F, 0x08, 0x14, 0x22, 0x41, 0x00, 0x00, 0x00}, // U+004B (K)
     {0x7F, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00, 0x00}, // U+004C (L)
     {0x7F, 0x02, 0x0C, 0x02, 0x7F, 0x00, 0x00, 0x00}, // U+004D (M)
     {0x7F, 0x04, 0x08, 0x10, 0x7F, 0x00, 0x00, 0x00}, // U+004E (N)
     {0x3E, 0x41, 0x41, 0x41, 0x3E, 0x00, 0x00, 0x00}, // U+004F (O)
     {0x7F, 0x09, 0x09, 0x09, 0x06, 0x00, 0x00, 0x00}, // U+0050 (P)
     {0x3E, 0x41, 0x51, 0x21, 0x5E, 0x00, 0x00, 0x00}, // U+0051 (Q)
     {0x7F, 0x09, 0x19, 0x29, 0x46, 0x00, 0x00, 0x00}, // U+0052 (R)
     {0x46, 0x49, 0x49, 0x49, 0x31, 0x00, 0x00, 0x00}, // U+0053 (S)
     {0x01, 0x01, 0x7F, 0x01, 0x01, 0x00, 0x00, 0x00}, // U+0054 (T)
     {0x3F, 0x40, 0x40, 0x40, 0x3F, 0x00, 0x00, 0x00}, // U+0055 (U)
     {0x1F, 0x20, 0x40, 0x20, 0x1F, 0x00, 0x00, 0x00}, // U+0056 (V)
     {0x3F, 0x40, 0x38, 0x40, 0x3F, 0x00, 0x00, 0x00}, // U+0057 (W)
     {0x63, 0x14, 0x08, 0x14, 0x63, 0x00, 0x00, 0x00}, // U+0058 (X)
     {0x07, 0x08, 0x70, 0x08, 0x07, 0x00, 0x00, 0x00}, // U+0059 (Y)
     {0x61, 0x51, 0x49, 0x45, 0x43, 0x00, 0x00, 0x00}, // U+005A (Z)
     {0x00, 0x7F, 0x41, 0x41, 0x00, 0x00, 0x00, 0x00}, // U+005B ([)
     {0x02, 0x04, 0x08, 0x10, 0x20, 0x00, 0x00, 0x00}, // U+005C (\)
     {0x00, 0x41, 0x41, 0x7F, 0x00, 0x00, 0x00, 0x00}, // U+005D (])
     {0x04, 0x02, 0x01, 0x02, 0x04, 0x00, 0x00, 0x00}, // U+005E (^)
     {0x40, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00, 0x00}, // U+005F (_)
     {0x00, 0x01, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00}, // U+0060 (`)
     {0x20, 0x54, 0x54, 0x54, 0x78, 0x00, 0x00, 0x00}, // U+0061 (a)
     {0x7F, 0x48, 0x44, 0x44, 0x38, 0x00, 0x00, 0x00}, // U+0062 (b)
     {0x38, 0x44, 0x44, 0x44, 0x20, 0x00, 0x00, 0x00}, // U+0063 (c)
     {0x38, 0x44, 0x44, 0x48, 0x7F, 0x00, 0x00, 0x00}, // U+0064 (d)
     {0x38, 0x54, 0x54, 0x54, 0x18, 0x00, 0x00, 0x00}, // U+0065 (e)
     {0x08, 0x7E, 0x09, 0x01, 0x02, 0x00, 0x00, 0x00}, // U+0066 (f)
     {0x0C, 0x52, 0x52, 0x52, 0x3E, 0x00, 0x00, 0x00}, // U+0067 (g)
     {0x7F, 0x08, 0x04, 0x04, 0x78, 0x00, 0x00, 0x00}, // U+0068 (h)
     {0x00, 0x44, 0x7D, 0x40, 0x00, 0x00, 0x00, 0x00}, // U+0069 (i)
     {0x20, 0x40, 0x44, 0x3D, 0x00, 0x00, 0x00, 0x00}, // U+006A (j)
     {0x7F, 0x10, 0x28, 0x44, 0x00, 0x00, 0x00, 0x00}, // U+006B (k)
     {0x00, 0x41, 0x7F, 0x40, 0x00, 0x00, 0x00, 0x00}, // U+006C (l)
     {0x7C, 0x04, 0x18, 0x04, 0x78, 0x00, 0x00, 0x00}, // U+006D (m)
     {0x7C, 0x08, 0x04, 0x04, 0x78, 0x00, 0x00, 0x00}, // U+006E (n)
     {0x38, 0x44, 0x44, 0x44, 0x38, 0x00, 0x00, 0x00}, // U+006F (o)
     {0x7C, 0x14, 0x14, 0x14, 0x08, 0x00, 0x00, 0x00}, // U+0070 (p)
     {0x08, 0x14, 0x14, 0x18, 0x7C, 0x00, 0x00, 0x00}, // U+0071 (q)
     {0x7C, 0x08, 0x04, 0x04, 0x08, 0x00, 0x00, 0x00}, // U+0072 (r)
     {0x48, 0x54, 0x54, 0x54, 0x20, 0x00, 0x00, 0x00}, // U+0073 (s)
     {0x04, 0x3F, 0x44, 0x40, 0x20, 0x00, 0x00, 0x00}, // U+0074 (t)
     {0x3C, 0x40, 0x40, 0x20, 0x7C, 0x00, 0x00, 0x00}, // U+0075 (u)
     {0x1C, 0x20, 0x40, 0x20, 0x1C, 0x00, 0x00, 0x00}, // U+0076 (v)
     {0x3C, 0x40, 0x30, 0x40, 0x3C, 0x00, 0x00, 0x00}, // U+0077 (w)
     {0x44, 0x28, 0x10, 0x28, 0x44, 0x00, 0x00, 0x00}, // U+0078 (x)
     {0x0C, 0x50, 0x50, 0x50, 0x3C, 0x00, 0x00, 0x00}, // U+0079 (y)
     {0x44, 0x64, 0x54, 0x4C, 0x44, 0x00, 0x00, 0x00}, // U+007A (z)
     {0x00, 0x08, 0x36, 0x41, 0x00, 0x00, 0x00, 0x00}, // U+007B ({)
     {0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00}, // U+007C (|)
     {0x00, 0x41, 0x36, 0x08, 0x00, 0x00, 0x00, 0x00}, // U+007D (})
     {0x10, 0x08, 0x08, 0x10, 0x08, 0x00, 0x00, 0x00}, // U+007E (~)
     {0x78, 0x46, 0x41, 0x46, 0x78, 0x00, 0x00, 0x00}, // U+007F 
     // Special characters
     {0x08, 0x0C, 0x7E, 0x0C, 0x08, 0x00, 0x00, 0x00}, // U+007F (Custom: Arrow Right)
     {0x10, 0x30, 0x7E, 0x30, 0x10, 0x00, 0x00, 0x00}, // U+007E (Custom: Arrow Left)
     {0x00, 0x20, 0x40, 0x3E, 0x01, 0x00, 0x00, 0x00}, // U+007D (Custom: Check mark)
     {0x41, 0x22, 0x14, 0x08, 0x14, 0x22, 0x41, 0x00}, // U+007C (Custom: Cross)
     {0x1C, 0x3E, 0x7C, 0x7C, 0x3E, 0x1C, 0x00, 0x00}, // U+007B (Custom: Heart)
     {0x06, 0x09, 0x09, 0x06, 0x00, 0x00, 0x00, 0x00}  // U+007A (Custom: Degree symbol)
 };
 
 #endif // MATRIX_LOGGER_H